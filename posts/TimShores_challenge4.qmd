---
title: "Challenge 4"
author: "Tim Shores"
description: "More data wrangling: pivoting"
date: "03/18/2023"
format:
  html:
    toc: true
    code-fold: true
    code-copy: true
    code-tools: true
    link-external-icon: true
    link-external-newwindow: true
    link-external-filter: '^(?:http:|https:)\/\/www\.quarto\.org\/custom'
categories:
  - challenge_4
  - eggs
---

```{r}
#| label: setup
#| warning: false
#| message: false

#| label: setup
#| warning: false
#| message: false

my_packages <- c("tidyverse", "readxl", "knitr", "zoo") # create vector of packages
invisible(lapply(my_packages, require, character.only = TRUE)) # load multiple packages


knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE)
```

## Challenge Overview

Challenge 4 includes four tasks:

1)  read in a data set, and describe the data set using both words and any supporting information (e.g., tables, etc)
2)  tidy data (as needed, including sanity checks)
3)  identify variables that need to be mutated
4)  mutate variables and sanity check all mutations

## Task 1) Read in, Tidy, and Describe the Data

I chose to read in the organic egg file, organiceggpoultry.xls. I use the same process as in [my Challenge 3 submission](https://dacss.github.io/601_Spring_2023/posts/TimShores_challenge3.html){.external target="_blank"}. I left out the details in this post, and show only the first 18 of 1,080 lines of the final data frame.

```{r}
listEggDFs <- map(set_names(excel_sheets("../posts/_data/organiceggpoultry.xls")),
read_xls, path = "../posts/_data/organiceggpoultry.xls") # read in all sheets as dataframes in a list

df_eggPoultryData <- map(names(listEggDFs), ~assign(.x, listEggDFs[[.x]], envir = .GlobalEnv))[[1]] # assign the first df in the list to a separate df

productname <- c(df_eggPoultryData[2,1],df_eggPoultryData[2,7]) # Store header values in list variables for use after pivot.
unitname <- c(df_eggPoultryData[3,1],df_eggPoultryData[3,7])

colnames(df_eggPoultryData) <- df_eggPoultryData[4, ] # Assign values from the 4th populated row to column names
colnames(df_eggPoultryData)[1] <- "month" # source data has no name in date column

df_eggPoultryData <- df_eggPoultryData %>% 
  slice(-(1:4)) %>% # Slice off the first four rows, which do not have table data.
  select(!`NA`) %>% # Select all columns but the empty one in the middle
  separate_wider_delim(month, delim = " ", names = c("month", "year"), too_few = "align_start", too_many = "merge") %>% 
  mutate(month = replace(month, month == 'Jan', 'January')) %>%
  mutate(year = replace(year, year == '/1', NA)) %>%
  fill(year) %>% # tidy the month column and separate year into its own column. 
  pivot_longer(cols = -c(month,year), names_to = "item", values_to = "price") %>% # to pivot the egg and chicken product column headings into row values under a new `item` column, with their values listed in a `price` column
  mutate(item = str_remove_all(item, '\\n')) %>% # tidy up item values and make labels consistent
  mutate(item = str_remove_all(item, '1/2 Dozen')) %>%
  mutate(item = str_replace_all(item, 'Doz\\.','Dozen')) %>%
  mutate(product = case_when( # assign the egg and chicken product and unit variables that I recorded earlier according to each egg and chicken item
    str_detect(item, regex("^[EL]")) ~ productname[[1]],
    str_detect(item, regex("^[BTW]")) ~ productname[[2]]
    )) %>% 
  mutate(unit = case_when( 
    str_detect(item, regex("^[EL]")) ~ unitname[[1]],
    str_detect(item, regex("^[BTW]")) ~ unitname[[2]]
    )) %>%
  print(n=18) # print a sample of the table
```

### Briefly describe the data

The data describes the price of several types of USDA certified organic egg and chicken products from the years 2004 to 2013. The price was paid by 'first receivers', described in a footnote as "those entities that purchases the processed product from the poultry or egg company, such as a retailer, distributor, or manufacturer." The cited data sources are the U.S. Department of Agriculture, Agricultural Marketing Service (AMS) Market News, Organic Poultry and Eggs (Weekly reports).

The data includes `r ncol(df_eggPoultryData)` variables (date, 4 egg carton items and 5 chicken items, and an empty column) with prices for `r ncol(df_eggPoultryData) - 2` items for each month of 10 years in `r nrow(df_eggPoultryData) - 4` rows.


## Identify variables that need to be mutated

In the Tidying code block above, I pivot the source data columns to a single `item` column. I then use several mutate functions to make the data more consistent and apply labels from other metadata taken from the original header.

I also use mutate to create a month and year column, but these variables are still character data types. 

The `lubridate` package wants to use dates or datetimes. It can do calculations with periods such as months, but the output is still dates or datetimes rather than months. I could pick the 1st of each month to work around this limitation, but there's another option ...

The `zoo` package `yearmon` class can return a year and month combo to represent dates on in monthly units. I like that! I decided to use `zoo` instead of `lubridate` for this specific case.

```{r}
df_eggPoultryData$month <- as.yearmon(paste(df_eggPoultryData$year, df_eggPoultryData$month), "%Y %B")
df_eggPoultryData <- subset(df_eggPoultryData, select = -c(year))
print(df_eggPoultryData, n=18)
```

I con
