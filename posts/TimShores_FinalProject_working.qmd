---
title: "Final Project Assignment #2: Tim Shores"
author: "Tim Shores"
description: "Project & Data Description"
date: "04/09/2023"
format:
  html:
    df-print: paged
    toc: true
    code-copy: true
    code-tools: true
    css: styles.css
categories:
  - final_Project_assignment_1
  - final_project_data_description
editor_options: 
  chunk_output_type: console
---

```{r}
#| label: setup
#| warning: false
#| message: false

my_packages <- c("tidyverse", "fs", "pdftools", "knitr") # create vector of packages
invisible(lapply(my_packages, require, character.only = TRUE)) # load multiple packages

knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE)
```

Read 'em and weep

```{r}
projectFiles <- dir_ls('posts/TimShores_FinalProject_Data') # creates fs_path vector of each file in that directory

projectFiles_list <- projectFiles %>%
  map(pdf_data) # purrr function that applies pdf_data reading function to each file element of fs_path vector
  # map creates a list of lists of tibbles (a tibble for each page of each pdf)

  # now that I've consumed my files I can trim down to the basic info stored in each filename
  # for use in the final data frame
projectFiles <- projectFiles %>% 
  str_replace('posts/TimShores_FinalProject_Data/', '') %>%
  str_replace('.pdf', '') 
names(projectFiles_list) <- projectFiles

  # This next part took a couple days of searching for a tidy solution. Then I just decided to use a good old fashioned
  # nested for loop.
  # The structure of the original documents is that each of 10 files has a variable number of pages.
  # Therefore, the projectFiles_list structure is a nested: list[[list]][[dataframe]]. 
  # I want to mutate each df with its page number -- this corresponds to its nested list element index (j in list[[i]][[j]]) which 
  # is information that gets destroyed as soon as I map to an unnested list. I couldn't find a tidy solution to capturing that nested
  # "sub" page id before the map, so I used a nested for loop to assign value to sub_page_id before appending my mapped/mutated df to
  # a new single-layer list.
allYearsList <- list()
for (i in seq_along(projectFiles_list)) { # seq_along(projectFiles_list) creates vector with a number value for each list element
  for (j in seq_along(projectFiles_list[[i]])) {
    projectFiles_list[[i]][[j]] <- mutate(projectFiles_list[[i]][[j]], sub_page_id = j)
  }
  allYearsList <- append(allYearsList, map2(projectFiles_list[[i]], 
                                            names(projectFiles_list[i]), 
                                            ~.x %>% 
                                              mutate(filename = .y)
                                            )
                         )
  }

  # this bind_rows takes all of the df observations from many list elements and binds them together in a single df.
  # abs_page_id is the 'page' number in an absolute sequence (1 to 78 in this case) rather than segmented by file (1 to 9, 1 to 7 etc.)
allYearsDF <- allYearsList %>%
  bind_rows(.id = 'abs_page_id') %>% 
  relocate(c(filename, sub_page_id), .after = abs_page_id) %>%
  filter(height == 11 & y > 13 & text != "Action:")
  
    # the above group_by and mutate, and the select(-row) below, are to resolve
    # the warning message "Values from `text` are not uniquely identified; 
    # output will contain list-cols" ... those list-cols are not easy to
    # deal with !

  # this creates a problem of staggered lines
allYearsDF_wide <- allYearsDF %>% 
  pivot_wider(id_cols = c(abs_page_id, filename, sub_page_id, y), names_from = x, values_from = text)

# solution from https://stackoverflow.com/questions/45515218/combine-rows-in-data-frame-containing-na-to-make-complete-row
# Supply lists by splicing them into dots:
coalesce_by_column <- function(df) {
  return(dplyr::coalesce(!!! as.list(df)))
}

allYearsDF_wide <- allYearsDF_wide %>%
  mutate(abs_page_id = as.integer(abs_page_id))

allYearsDF_wide <- allYearsDF_wide %>%
  group_by(abs_page_id, filename, sub_page_id, y) %>% # I think abs_page_id and filename together are redundant
  summarise_all(coalesce_by_column) %>%
  ungroup()
# do I need to ungroup() ?

  # it will help to order columns by numeric order - they are the x coords from left to right. This looks for all non-alpha column names.
numcols = sort(as.numeric(names(allYearsDF_wide)[!grepl("[a-z]", names(allYearsDF_wide))]))
allYearsDF_wide <- select(allYearsDF_wide, abs_page_id, filename, sub_page_id, y, match(numcols, names(allYearsDF_wide))) 
  # now we have a df that is simply x:y coordinates of the page
  # time to smush cols together!
allYearsDF_wide <- unite(allYearsDF_wide, "x5to52", c("5":"47"), sep = " ", na.rm = TRUE, remove = TRUE)
allYearsDF_wide <- unite(allYearsDF_wide, "x53to197", c("53":"197"), sep = " ", na.rm = TRUE, remove = TRUE)
allYearsDF_wide <- unite(allYearsDF_wide, "x198to238", c("198":"233"), sep = " ", na.rm = TRUE, remove = TRUE)
allYearsDF_wide <- unite(allYearsDF_wide, "x239to280", c("239":"270"), sep = " ", na.rm = TRUE, remove = TRUE)
allYearsDF_wide <- unite(allYearsDF_wide, "x281to329", c("281":"329"), sep = " ", na.rm = TRUE, remove = TRUE)
allYearsDF_wide <- unite(allYearsDF_wide, "x330to371", c("330":"371"), sep = " ", na.rm = TRUE, remove = TRUE)
allYearsDF_wide <- unite(allYearsDF_wide, "x372to449", c("372":"431"), sep = " ", na.rm = TRUE, remove = TRUE)
allYearsDF_wide <- unite(allYearsDF_wide, "x450toEnd", c("450":"545"), sep = " ", na.rm = TRUE, remove = TRUE)
  # note that spacing does differ on each page (as indicated by the colnames), but the boundaries are stable
  # (as indicated by the united colnames -- I manually confirmed pixel widths on the pdf report)

  # final tidying of Call_Reason text separated into different columns
allYearsDF_wide <- mutate(allYearsDF_wide, 
                          x5to52 = ifelse(nchar(x5to52, type="chars") > 0 & nchar(x53to197, type="chars") > 0, 
                                          paste0(x5to52," ",x53to197), 
                                          paste0(x5to52)),
                          x53to197 = ifelse(nchar(x5to52, type="chars") > 0, 
                                            paste0(""), 
                                            paste0(x53to197))) # delete from additional columns

allYearsDF_wide <- mutate(allYearsDF_wide, 
                          x53to197 = ifelse(x53to197 == "", paste0(""), paste0(x53to197, " ", x198to238, " ", x239to280, " ", x281to329, " ", x330to371, " ", x372to449, " ", x450toEnd)),
                          x198to238 = ifelse(nchar(x53to197, type="chars") > 0, paste0(""), paste0(x198to238)), # delete from add'l cols
                          x239to280 = ifelse(nchar(x53to197, type="chars") > 0, paste0(""), paste0(x239to280)), # delete from add'l cols
                          x281to329 = ifelse(nchar(x53to197, type="chars") > 0, paste0(""), paste0(x281to329)), # delete from add'l cols
                          x330to371 = ifelse(nchar(x53to197, type="chars") > 0, paste0(""), paste0(x330to371)), # delete from add'l cols
                          x372to449 = ifelse(nchar(x53to197, type="chars") > 0, paste0(""), paste0(x372to449)), # delete from add'l cols
                          x450toEnd = ifelse(nchar(x53to197, type="chars") > 0, paste0(""), paste0(x450toEnd)) # delete from add'l cols
                          )

allYearsDF_wide <- allYearsDF_wide %>% mutate_at(c(5,6), ~na_if(., '')) # replace blanks with NAs in the 2nd and 3rd cols. I tried this using paste in the previous mutate, but the result was a text string "NA".
  # label each action with its call type
allYearsDF_wide <- fill(allYearsDF_wide, x5to52, .direction = "down")
allYearsDF_wide <- allYearsDF_wide %>% 
  mutate(x53to197 = ifelse(row_number() == 1, "Action", x53to197))
colnames(allYearsDF_wide)[-c(1:4)] <- allYearsDF_wide[1,-c(1:4)]
allYearsDF_wide <- allYearsDF_wide %>% 
  rename_with(tolower) %>%
  rename_with(~ gsub("._", "_", .x, fixed = TRUE)) %>%
  rename_with(~ gsub("@", "at", .x, fixed = TRUE))

allYearsDF_wide <- allYearsDF_wide %>%
  filter(sub_page_id != 1 | y != 69 | call_reason != "Call_Reason") %>%
  filter(self != "Self_Init") %>%
  # sep filename into town and year
  separate_wider_regex(filename, c(town = "^[A-Za-z]+", year = "[0-9]{4}$")) %>%
  mutate(town = factor(town),
         year = make_date(year = as.integer(year), month = 1, day = 1)) %>%
  select(-c(total, "___%")) %>%
  mutate(across(call_reason:avg_time_at_scene, ~na_if(., "")))

#  mutate_at(c('self':'avg_time_at_scene'), funs(str_replace(., "", '0')))
  # this doesn't work but I think I might not need it

callTypesDF <- allYearsDF_wide %>% # I think this completes the first df
  filter(is.na(action)) %>% 
  filter(!grepl("total", call_reason, ignore.case = TRUE)) %>%
  filter(!is.na(self)) %>%
  select(-action) %>%
  mutate(call_reason = factor(call_reason)) %>%
  mutate_at(c("self", "disp", "avg_arrive", "avg_time_at_scene"), as.numeric) %>%
  mutate(avg_arrive = ifelse(is.na(avg_arrive), 0, avg_arrive)) 

# sanity check ... pass!
callTypesDF %>%
  group_by(town) %>%
  summarise(selfSum = sum(as.numeric(self)), dispSum = sum(as.numeric(disp)), arriveSum = sum(as.numeric(avg_arrive)), sceneSum = sum(as.numeric(avg_time_at_scene)), .groups = 'drop')

######### all good up to this point.
######### To do:
######### May need to trim

callActionsDF <- allYearsDF_wide
operatorSummaryDF <- allYearsDF_wide

## testers
allYearsDF_wideACTION <- arrange(allYearsDF_wide, Action)
allYearsDF_wideSELF <- arrange(allYearsDF_wide, desc(Self)) # checks out 
```


