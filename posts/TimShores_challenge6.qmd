---
title: "Challenge 6"
author: "Tim Shores"
description: "Visualizing Time and Relationships"
date: "03/31/2023"
format:
  html:
    df-print: paged
    toc: true
    code-copy: true
    code-tools: true
    css: styles.css
categories:
  - challenge_6
  - hotel_bookings
---

```{r}
#| label: setup
#| warning: false
#| message: false

my_packages <- c("tidyverse", "ggplot2", "treemap", "knitr") # create vector of packages
invisible(lapply(my_packages, require, character.only = TRUE)) # load multiple packages

knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE)
```

## Read in data

I chose to read in hotel_bookings.csv. My high school computer science teacher taught us that laziness is the key to quality computer science. I read in the hotel bookings data in Challenge 2. Therefore, I get to reuse my code from that earlier lesson. Quality computing!

```{r}

#| echo: true
hotelbks <- read.csv(file = "../posts/_data/hotel_bookings.csv") # read in data
hbrows <- prettyNum(nrow(hotelbks), big.mark = ",", scientific = FALSE)  # Apply comma-separated format
hbcols <- prettyNum(ncol(hotelbks), big.mark = ",", scientific = FALSE)
```

Plus, I learned about the quarto format option *df-print: paged*. Much nicer!

```{r}
hotelbks
```

### Briefly describe the data

The hotel bookings set includes **`r hbrows`** observations under **`r hbcols`** variables. It shows operational business data from multiple hotels in multiple markets and countries, managed by multiple companies. The data is likely the product of market research produced by a third-party analyst or management consultant.

I'm going to use plots to see how ADR changes over time, and to see how countries and market segments rank in terms of ADR.

## Tidy Data (as needed)

I need to mutate the three date variables into a single Arrival Date variable. The original month variable uses full month names. By displaying the distinct values in that column, I confirm all rows are spelled correctly, and there are 12 distinct values. 

```{r}
hotelbks %>%
  distinct(arrival_date_month)

```

Without additional tidying needed, I can mutate to convert month names into an integer before piping to the lubridate make_date function.

I also convert Market Segment variable to a factor, filter out canceled reservations from the resulting subset, filter out observations with 0 ADR (average daily rate), and filter out any reservations where both the Stay in Weekday Nights and the Stay in Weekend Nights are 0.

```{r}
hotelsub <- hotelbks %>%
  mutate(
    arrival_date_month = as.integer(factor(arrival_date_month, levels = month.name)),
    arrival_date = make_date(year = arrival_date_year, month = arrival_date_month, day = arrival_date_day_of_month),
    market_segment = factor(market_segment)) %>%
    filter(is_canceled == 0 & adr > 0 & (stays_in_weekend_nights > 0 | stays_in_week_nights > 0)) %>%
  subset(select = c(arrival_date, stays_in_weekend_nights, stays_in_week_nights, adr, country, market_segment))

hotelsub
```

To see information about ADR, we don't need observations of canceled reservations, stays with no ADR, or stays with 0 nights. 

Stays with no ADR could be the result of a discount or other compensation -- either way, we can omit these from the totals. 

Stays with 0 nights could refer to stays where a guest checked in and checked out in the same day, but it could also be an error. We can omit these from the totals.

My resulting subset has no NA values.

```{r}
# count unique and missing values
hotelsub %>% summarise(
  #dateDist = n_distinct(arrival_date),
  dateNA = sum(is.na(arrival_date)),
  #weekendDist = n_distinct(stays_in_weekend_nights),
  weekendNA = sum(is.na(stays_in_weekend_nights)),
  #weekdayDist = n_distinct(stays_in_week_nights),
  weekdayNA = sum(is.na(stays_in_week_nights)),
  #adrDist = n_distinct(adr),
  adrNA = sum(is.na(adr)),
  #countryDist = n_distinct(country),
  countryNA = sum(is.na(country)),
  #markDist = n_distinct(market_segment),
  markNA = sum(is.na(market_segment)))

```

Before I visualize, I'll create two new dataframes: one grouped by Country, another grouped by Market Segment. I'll arrange by adrMean from highest to lowest, and slice to include the top 12 highest adrMean values in the country dataframe. This is not necessary in the market segment data frame, because there are only 7 segments.

```{r}

hotelByDay <- hotelsub %>%
  group_by(arrival_date) %>%
  summarise(weekendSum = sum(stays_in_weekend_nights),
            weekdaySum = sum(stays_in_week_nights),
            adrMean = num(mean(adr), digits = 2)) %>%
  subset(select = c(arrival_date, weekendSum, weekdaySum, adrMean))

hotelByDay

hotelByCountry <- hotelsub %>%
  group_by(country) %>%
  summarise(weekendSum = sum(stays_in_weekend_nights),
            weekdaySum = sum(stays_in_week_nights),
            adrMean = num(mean(adr), digits = 2)) %>%
  subset(select = c(country, weekendSum, weekdaySum, adrMean)) %>%
  arrange(desc(adrMean)) %>%
  slice_head(n = 12)

hotelByCountry

hotelBySegment <- hotelsub %>%
  group_by(market_segment) %>%
  summarise(weekendSum = sum(stays_in_weekend_nights),
            weekdaySum = sum(stays_in_week_nights),
            adrMean = num(mean(adr), digits = 2)) %>%
  subset(select = c(market_segment, weekendSum, weekdaySum, adrMean))

hotelBySegment

```

## Time Dependent Visualization

```{r}
ggplot(hotelByDay, aes(x=arrival_date, y=adrMean)) +
  geom_line() + 
  xlab("")

```

## Visualizing Part-Whole Relationships

```{r}
treemap(hotelByCountry,
            index="country",
            vSize="adrMean",
            type="index"
            )

treemap(hotelBySegment,
            index="market_segment",
            vSize="adrMean",
            type="index"
            )

```